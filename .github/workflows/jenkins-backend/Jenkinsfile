//jenkins pipeline
pipeline {
    agent any

    tools {
        nodejs 'Node20.20' //calling the tool name in tool configuration because there are several tool names created with different versions, so we need to specify which one we want to use in this pipeline.
    //sonar 'SonarScanner'
    }

    environment {
        IMAGE_NAME = 'koyex1/backend' //{{repoName}}/{{appNameNotcontainerName}}
        SONARQUBE_ENV = 'SonarQube'
        TRIVY_CACHE_DIR = "${WORKSPACE}/.trivycache"
        SONAR_PROJECT_KEY = 'sonarqubepjt'
        SONAR_HOST_URL = 'http://sonarqube:9400'
        SONAR_TOKEN = credentials('sonartokenpjt')
    }

    options {
        timestamps()
        ansiColor('xterm')
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Install Dependencies') {
            steps {
                dir('backend') {
                    sh 'node -v'
                    sh 'npm -v'
                    sh 'npm ci'
                }
            }
        }

        stage('Lint') {
            steps {
                dir('backend') {
                    sh 'npm run lint'
                }
            }
        }

        stage('Test') {
            steps {
                dir('backend') {
                    sh 'npm test -- --coverage'
                }
            }
            post {
                always {
                    junit 'backend/**/junit.xml'
                    publishHTML(target: [
                        reportDir: 'backend/coverage',
                        reportFiles: 'index.html',
                        reportName: 'Test Coverage Report',
                        keepAll: true,
                        allowMissing: false,
                        alwaysLinkToLastBuild: true
                    ])
                }
            }
        }

        stage('SonarQube Analysis') {//collects data and sends it to SonarQube server for analysis. It does not wait for the results, so we need a separate stage to check the quality gate status after this.
            environment {
                scannerHome = tool 'SonarScanner' //this is from Jenkins global system configuration
            }

            steps {
                dir('backend') {
                    withSonarQubeEnv('sonarqubeserver') { //this is from Jenkins global system configuration
                        sh 'echo $SONAR_HOST_URL'      // ‚Üê Shows your URL
                        sh 'echo $SONAR_AUTH_TOKEN'

                        sh """
                           ${scannerHome}/bin/sonar-scanner \
                            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                            -Dsonar.sources=. \
                            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info
                        """
                        /*
                         ${scannerHome}/bin/sonar-scanner \
                            -Dsonar.host.url=${SONAR_HOST_URL} \
                            -Dsonar.login=${SONAR_TOKEN} \
                            -Dsonar.projectKey=${SONAR_PROJECT_KEY}
                        */
                    }
                }
            }
        }

        stage('SonarQube Quality Gate') { //data collected by sonar scanner is analyzed by quality gate, and we need to check the status of the quality gate to decide whether to proceed with the pipeline or not. If the quality gate fails, we can abort the pipeline.
            steps {
                timeout(time: 2, unit: 'MINUTES') {
                    waitForQualityGate abortPipeline: false
                }
            }
        }

        stage('Filesystem Dependency Scan (Trivy)') {
            steps {
                sh """
                  docker run --rm \
                    -v ${WORKSPACE}/backend:/project \
                    -v ${TRIVY_CACHE_DIR}:/root/.cache \
                    aquasec/trivy:latest \
                    fs \
                    --format json \
                    --output trivy-fs-report.json \
                    --severity CRITICAL,HIGH \
                    --exit-code 1 \
                    /project
                """
            }
            post {
                always {
                    archiveArtifacts artifacts: './backend/**/trivy-fs-report.json',
                    fingerprint: true
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                sh """
                  docker build -t ${env.IMAGE_NAME}:jenkins${env.BUILD_NUMBER}commit${env.GIT_COMMIT} backend
                  docker tag ${env.IMAGE_NAME}:jenkins${env.BUILD_NUMBER}commit${env.GIT_COMMIT} ${env.IMAGE_NAME}:latest
                """
            }
        }

        stage('Docker Image Scan (Trivy)') {
            steps {
                sh """
                  docker run --rm \
                    -v /var/run/docker.sock:/var/run/docker.sock \
                    -v ${TRIVY_CACHE_DIR}:/root/.cache \
                    aquasec/trivy:latest \
                    image \
                    --format json \
                    --output trivy-image-report.json \
                    --severity CRITICAL,HIGH \
                    --exit-code 1 \
                    ${env.IMAGE_NAME}:jenkins${env.BUILD_NUMBER}commit${env.GIT_COMMIT}
                """
            }
            post {
                always {
                    archiveArtifacts artifacts: './backend/**/trivy-image-report.json',
                    fingerprint: true
                }
            }
        }

        stage('Push Image') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'dockerHubLogin',
                    usernameVariable: 'DOCKER_USER',
                    passwordVariable: 'DOCKER_PASS'
                )]) {
                    sh """
                      echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin
                      docker push ${env.IMAGE_NAME}:jenkins${env.BUILD_NUMBER}commit${env.GIT_COMMIT}
                      docker push ${env.IMAGE_NAME}:latest
                    """
                }
            }
        }

        stage('Deploy') {
            when {
                branch 'main'
            }

            steps {
                withCredentials([sshUserPrivateKey(
                    credentialsId: 'server-ssh',
                    keyFileVariable: 'SSH_KEY',
                    usernameVariable: 'SSH_USER'
                )]) {
                    sh """
                      ssh -i $SSH_KEY -o StrictHostKeyChecking=no \
                      $SSH_USER@your.server.ip '
                        docker pull ${env.IMAGE_NAME}:latest &&
                        docker stop app || true &&
                        docker rm app || true &&
                        docker run -d \
                          --restart unless-stopped \
                          --name app \
                          -p 4000:4000 \
                          ${env.IMAGE_NAME}:latest
                      '
                    """
                }
            }
        }
    }

    post { //similar to pre and post configurationn.
        always {
            cleanWs()  //used to clean the workspace after the build is done, regardless of the build result. This helps to free up disk space and ensure that subsequent builds start with a clean environment.
        //but it does not delete the artifacts that have been archived, so you can still access those after the workspace is cleaned.
        }

        success {
            echo 'Pipeline completed successfully.'
        }

        failure {
            echo 'Pipeline failed.'
        }
    }
}

/*pipeline {
    agent any

    stages {

        stage('Check Path Changes') {
            when {
                anyOf {
                    changeset "**/backend/**"
                    changeset "**/.github/**"
                }
            }
            steps {
                echo "Relevant changes detected."
            }
        }

        stage('Build') {
            when {
                anyOf {
                    changeset "**/backend/**"
                    changeset "**/.github/**"
                }
            }
            steps {
                echo "Running build..."
                sh 'npm ci'
            }
        }

    }
}
*/
